--- a/internal/ceres/miniglog/glog/logging.h
+++ b/internal/ceres/miniglog/glog/logging.h
@@ -111,7 +111,7 @@
 // Log severity level constants.
 // clang-format off
 const int FATAL   = -3;
-const int ERROR   = -2;
+const int GLOG_ERROR   = -2;
 const int WARNING = -1;
 const int INFO    =  0;
 // clang-format on
@@ -124,7 +124,7 @@ using LogSeverity = int;
 // clang-format off
 const int INFO    = ::INFO;
 const int WARNING = ::WARNING;
-const int ERROR   = ::ERROR;
+const int GLOG_ERROR   = ::GLOG_ERROR;
 const int FATAL   = ::FATAL;
 // clang-format on
 
--- a/internal/ceres/block_jacobian_writer.cc
+++ b/internal/ceres/block_jacobian_writer.cc
@@ -91,7 +91,7 @@ bool BuildJacobianLayout(const Program& program,
       }
     }
     if (num_jacobian_blocks > std::numeric_limits<int>::max()) {
-      LOG(ERROR) << "Overlow error. Too many blocks in the jacobian matrix : "
+      LOG(GLOG_ERROR) << "Overlow error. Too many blocks in the jacobian matrix : "
                  << num_jacobian_blocks;
       return false;
     }
@@ -153,7 +153,7 @@ bool BuildJacobianLayout(const Program& program,
         jacobian_pos[k] = static_cast<int>(f_block_pos);
         f_block_pos += jacobian_block_size;
         if (f_block_pos > std::numeric_limits<int>::max()) {
-          LOG(ERROR)
+          LOG(GLOG_ERROR)
               << "Overlow error. Too many entries in the Jacobian matrix.";
           return false;
         }
@@ -195,7 +195,7 @@ BlockJacobianWriter::CreateEvaluatePreparers(unsigned num_threads) {
 
 std::unique_ptr<SparseMatrix> BlockJacobianWriter::CreateJacobian() const {
   if (!jacobian_layout_is_valid_) {
-    LOG(ERROR) << "Unable to create Jacobian matrix. Too many entries in the "
+    LOG(GLOG_ERROR) << "Unable to create Jacobian matrix. Too many entries in the "
                   "Jacobian matrix.";
     return nullptr;
   }

--- a/internal/ceres/compressed_row_jacobian_writer.cc
+++ b/internal/ceres/compressed_row_jacobian_writer.cc
@@ -106,7 +106,7 @@ std::unique_ptr<SparseMatrix> CompressedRowJacobianWriter::CreateJacobian()
       if (!parameter_block->IsConstant()) {
         num_jacobian_nonzeros += num_residuals * parameter_block->TangentSize();
         if (num_jacobian_nonzeros > std::numeric_limits<int>::max()) {
-          LOG(ERROR) << "Unable to create Jacobian matrix: Too many entries in "
+          LOG(GLOG_ERROR) << "Unable to create Jacobian matrix: Too many entries in "
                         "the Jacobian matrix. num_jacobian_nonzeros = "
                      << num_jacobian_nonzeros;
           return nullptr;

--- a/internal/ceres/covariance_impl.cc
+++ b/internal/ceres/covariance_impl.cc
@@ -186,7 +186,7 @@ bool CovarianceImpl::GetCovarianceBlockInTangentOrAmbientSpace(
   }
 
   if (offset == row_size) {
-    LOG(ERROR) << "Unable to find covariance block for "
+    LOG(GLOG_ERROR) << "Unable to find covariance block for "
                << original_parameter_block1 << " " << original_parameter_block2;
     return false;
   }
@@ -511,7 +511,7 @@ bool CovarianceImpl::ComputeCovarianceValues() {
 #if !defined(CERES_NO_SUITESPARSE)
       return ComputeCovarianceValuesUsingSuiteSparseQR();
 #else
-      LOG(ERROR) << "SuiteSparse is required to use the SPARSE_QR algorithm "
+      LOG(GLOG_ERROR) << "SuiteSparse is required to use the SPARSE_QR algorithm "
                  << "with "
                  << "Covariance::Options::sparse_linear_algebra_library_type "
                  << "= SUITE_SPARSE.";
@@ -519,7 +519,7 @@ bool CovarianceImpl::ComputeCovarianceValues() {
 #endif
     }
 
-    LOG(ERROR) << "Unsupported "
+    LOG(GLOG_ERROR) << "Unsupported "
                << "Covariance::Options::sparse_linear_algebra_library_type "
                << "= "
                << SparseLinearAlgebraLibraryTypeToString(
@@ -527,7 +527,7 @@ bool CovarianceImpl::ComputeCovarianceValues() {
     return false;
   }
 
-  LOG(ERROR) << "Unsupported Covariance::Options::algorithm_type = "
+  LOG(GLOG_ERROR) << "Unsupported Covariance::Options::algorithm_type = "
              << CovarianceAlgorithmTypeToString(options_.algorithm_type);
   return false;
 }
@@ -624,7 +624,7 @@ bool CovarianceImpl::ComputeCovarianceValuesUsingSuiteSparseQR() {
       &cc);
   event_logger.AddEvent("Numeric Factorization");
   if (R == nullptr) {
-    LOG(ERROR) << "Something is wrong. SuiteSparseQR returned R = nullptr.";
+    LOG(GLOG_ERROR) << "Something is wrong. SuiteSparseQR returned R = nullptr.";
     free(permutation);
     cholmod_l_finish(&cc);
     return false;
@@ -756,7 +756,7 @@ bool CovarianceImpl::ComputeCovarianceValuesUsingDenseSVD() {
       if (automatic_truncation) {
         break;
       } else {
-        LOG(ERROR) << "Error: Covariance matrix is near rank deficient "
+        LOG(GLOG_ERROR) << "Error: Covariance matrix is near rank deficient "
                    << "and the user did not specify a non-zero"
                    << "Covariance::Options::null_space_rank "
                    << "to enable the computation of a Pseudo-Inverse. "
@@ -826,12 +826,12 @@ bool CovarianceImpl::ComputeCovarianceValuesUsingEigenSparseQR() {
   event_logger.AddEvent("QRDecomposition");
 
   if (qr.info() != Eigen::Success) {
-    LOG(ERROR) << "Eigen::SparseQR decomposition failed.";
+    LOG(GLOG_ERROR) << "Eigen::SparseQR decomposition failed.";
     return false;
   }
 
   if (qr.rank() < jacobian.num_cols) {
-    LOG(ERROR) << "Jacobian matrix is rank deficient. "
+    LOG(GLOG_ERROR) << "Jacobian matrix is rank deficient. "
                << "Number of columns: " << jacobian.num_cols
                << " rank: " << qr.rank();
     return false;

--- a/internal/ceres/dogleg_strategy.cc
+++ b/internal/ceres/dogleg_strategy.cc
@@ -577,7 +577,7 @@ LinearSolver::Summary DoglegStrategy::ComputeGaussNewtonStep(
                                          residuals,
                                          gauss_newton_step_.data(),
                                          0)) {
-        LOG(ERROR) << "Unable to dump trust region problem."
+        LOG(GLOG_ERROR) << "Unable to dump trust region problem."
                    << " Filename base: "
                    << per_solve_options.dump_filename_base;
       }
@@ -656,7 +656,7 @@ bool DoglegStrategy::ComputeSubspaceModel(SparseMatrix* jacobian) {
       // This should never happen, as it implies that both the gradient
       // and the Gauss-Newton step are zero. In this case, the minimizer should
       // have stopped due to the gradient being too small.
-      LOG(ERROR) << "Rank of subspace basis is 0. "
+      LOG(GLOG_ERROR) << "Rank of subspace basis is 0. "
                  << "This means that the gradient at the current iterate is "
                  << "zero but the optimization has not been terminated. "
                  << "You may have found a bug in Ceres.";
@@ -674,7 +674,7 @@ bool DoglegStrategy::ComputeSubspaceModel(SparseMatrix* jacobian) {
       break;
 
     default:
-      LOG(ERROR) << "Rank of the subspace basis matrix is reported to be "
+      LOG(GLOG_ERROR) << "Rank of the subspace basis matrix is reported to be "
                  << "greater than 2. As the matrix contains only two "
                  << "columns this cannot be true and is indicative of "
                  << "a bug.";

--- a/internal/ceres/gmock/gmock.h
+++ b/internal/ceres/gmock/gmock.h
@@ -10205,7 +10205,7 @@ GTEST_DISABLE_MSC_WARNINGS_POP_()  //  4251
 //
 //   // Oops! Which overload did you want?
 //   ON_CALL(mock, OverloadedMethod).WillByDefault(...);
-//     => ERROR: call to member function 'gmock_OverloadedMethod' is ambiguous
+//     => GLOG_ERROR: call to member function 'gmock_OverloadedMethod' is ambiguous
 //
 // How this works: The mock class uses two overloads of the gmock_Method
 // expectation setter method plus an operator() overload on the MockSpec object.

--- a/internal/ceres/gmock_gtest_all.cc
+++ b/internal/ceres/gmock_gtest_all.cc
@@ -2024,7 +2024,7 @@ void TypeParameterizedTestSuiteRegistry::RegisterInstantiation(
   if (it != suites_.end()) {
     it->second.instantiated = true;
   } else {
-    GTEST_LOG_(ERROR) << "Unknown type parameterized test suit '"
+    GTEST_LOG_(GLOG_ERROR) << "Unknown type parameterized test suit '"
                       << test_suite_name << "'";
   }
 }
@@ -4269,7 +4269,7 @@ void ReportInvalidTestSuiteType(const char* test_suite_name,
       << "probably rename one of the classes to put the tests into different\n"
       << "test suites.";
 
-  GTEST_LOG_(ERROR) << FormatFileLocation(code_location.file.c_str(),
+  GTEST_LOG_(GLOG_ERROR) << FormatFileLocation(code_location.file.c_str(),
                                           code_location.line)
                     << " " << errors.GetString();
 }
@@ -6514,7 +6514,7 @@ class ScopedPrematureExitFile {
     if (!premature_exit_filepath_.empty()) {
       int retval = remove(premature_exit_filepath_.c_str());
       if (retval) {
-        GTEST_LOG_(ERROR) << "Failed to remove premature exit filepath \""
+        GTEST_LOG_(GLOG_ERROR) << "Failed to remove premature exit filepath \""
                           << premature_exit_filepath_ << "\" with error "
                           << retval;
       }
@@ -11381,7 +11381,7 @@ GTestLog::GTestLog(GTestLogSeverity severity, const char* file, int line)
   const char* const marker =
       severity == GTEST_INFO ?    "[  INFO ]" :
       severity == GTEST_WARNING ? "[WARNING]" :
-      severity == GTEST_ERROR ?   "[ ERROR ]" : "[ FATAL ]";
+      severity == GTEST_ERROR ?   "[ GLOG_ERROR ]" : "[ FATAL ]";
   GetStream() << ::std::endl << marker << " "
               << FormatFileLocation(file, line).c_str() << ": ";
 }
@@ -13972,7 +13972,7 @@ class MockObjectRegistry {
       const MockObjectState& state = it->second;
       std::cout << internal::FormatFileLocation(state.first_used_file,
                                                 state.first_used_line);
-      std::cout << " ERROR: this mock object";
+      std::cout << " GLOG_ERROR: this mock object";
       if (state.first_used_test != "") {
         std::cout << " (used in test " << state.first_used_test_suite << "."
                   << state.first_used_test << ")";

--- a/internal/ceres/gradient_checking_cost_function.cc
+++ b/internal/ceres/gradient_checking_cost_function.cc
@@ -134,7 +134,7 @@ GradientCheckingIterationCallback::GradientCheckingIterationCallback()
 CallbackReturnType GradientCheckingIterationCallback::operator()(
     const IterationSummary& /*summary*/) {
   if (gradient_error_detected_) {
-    LOG(ERROR) << "Gradient error detected. Terminating solver.";
+    LOG(GLOG_ERROR) << "Gradient error detected. Terminating solver.";
     return SOLVER_ABORT;
   }
   return SOLVER_CONTINUE;

--- a/internal/ceres/gradient_problem_solver.cc
+++ b/internal/ceres/gradient_problem_solver.cc
@@ -123,7 +123,7 @@ void GradientProblemSolver::Solve(const GradientProblemSolver::Options& options,
 
   // Check validity
   if (!options.IsValid(&summary->message)) {
-    LOG(ERROR) << "Terminating: " << summary->message;
+    LOG(GLOG_ERROR) << "Terminating: " << summary->message;
     return;
   }
 

--- a/internal/ceres/levenberg_marquardt_strategy.cc
+++ b/internal/ceres/levenberg_marquardt_strategy.cc
@@ -142,7 +142,7 @@ TrustRegionStrategy::Summary LevenbergMarquardtStrategy::ComputeStep(
                                        residuals,
                                        step,
                                        0)) {
-      LOG(ERROR) << "Unable to dump trust region problem."
+      LOG(GLOG_ERROR) << "Unable to dump trust region problem."
                  << " Filename base: " << per_solve_options.dump_filename_base;
     }
   }

--- a/internal/ceres/line_search_direction.cc
+++ b/internal/ceres/line_search_direction.cc
@@ -362,7 +362,7 @@ std::unique_ptr<LineSearchDirection> LineSearchDirection::Create(
         options.use_approximate_eigenvalue_bfgs_scaling);
   }
 
-  LOG(ERROR) << "Unknown line search direction type: " << options.type;
+  LOG(GLOG_ERROR) << "Unknown line search direction type: " << options.type;
   return nullptr;
 }
 

--- a/internal/ceres/line_search_minimizer.cc
+++ b/internal/ceres/line_search_minimizer.cc
@@ -199,7 +199,7 @@ void LineSearchMinimizer::Minimize(const Minimizer::Options& options,
   if (line_search.get() == nullptr) {
     summary->termination_type = FAILURE;
     if (is_not_silent) {
-      LOG(ERROR) << "Terminating: " << summary->message;
+      LOG(GLOG_ERROR) << "Terminating: " << summary->message;
     }
     return;
   }

--- a/internal/ceres/miniglog/glog/logging.h
+++ b/internal/ceres/miniglog/glog/logging.h
@@ -124,7 +124,7 @@ using LogSeverity = int;
 // clang-format off
 const int INFO    = ::INFO;
 const int WARNING = ::WARNING;
-const int GLOG_ERROR   = ::GLOG_ERROR;
+const int ERROR   = ::GLOG_ERROR;
 const int FATAL   = ::FATAL;
 // clang-format on
 

--- a/internal/ceres/parallel_for_test.cc
+++ b/internal/ceres/parallel_for_test.cc
@@ -182,7 +182,7 @@ TEST(ParallelForWithThreadId, UniqueThreadIds) {
   // pass.
   const int num_hardware_threads = std::thread::hardware_concurrency();
   if (num_hardware_threads <= 1) {
-    LOG(ERROR)
+    LOG(GLOG_ERROR)
         << "Test not supported, the hardware does not support threading.";
     return;
   }

--- a/internal/ceres/polynomial.cc
+++ b/internal/ceres/polynomial.cc
@@ -183,7 +183,7 @@ bool FindPolynomialRoots(const Vector& polynomial_in,
                          Vector* real,
                          Vector* imaginary) {
   if (polynomial_in.size() == 0) {
-    LOG(ERROR) << "Invalid polynomial of size 0 passed to FindPolynomialRoots";
+    LOG(GLOG_ERROR) << "Invalid polynomial of size 0 passed to FindPolynomialRoots";
     return false;
   }
 
@@ -232,7 +232,7 @@ bool FindPolynomialRoots(const Vector& polynomial_in,
   // Find its (complex) eigenvalues.
   Eigen::EigenSolver<Matrix> solver(companion_matrix, false);
   if (solver.info() != Eigen::Success) {
-    LOG(ERROR) << "Failed to extract eigenvalues from companion matrix.";
+    LOG(GLOG_ERROR) << "Failed to extract eigenvalues from companion matrix.";
     return false;
   }
 

--- a/internal/ceres/polynomial.h
+++ b/internal/ceres/polynomial.h
@@ -64,7 +64,7 @@ inline double EvaluatePolynomial(const Vector& polynomial, double x) {
 // This function returns true on success, false otherwise.
 // Failure indicates that the polynomial is invalid (of size 0) or
 // that the eigenvalues of the companion matrix could not be computed.
-// On failure, a more detailed message will be written to LOG(ERROR).
+// On failure, a more detailed message will be written to LOG(GLOG_ERROR).
 // If real is not nullptr, the real parts of the roots will be returned in it.
 // Likewise, if imaginary is not nullptr, imaginary parts will be returned in
 // it.

--- a/internal/ceres/problem_impl.cc
+++ b/internal/ceres/problem_impl.cc
@@ -762,7 +762,7 @@ bool ProblemImpl::EvaluateResidualBlock(ResidualBlock* residual_block,
     ParameterBlock* parameter_block = parameter_blocks[i];
     if (parameter_block->IsConstant()) {
       if (jacobians != nullptr && jacobians[i] != nullptr) {
-        LOG(ERROR) << "Jacobian requested for parameter block : " << i
+        LOG(GLOG_ERROR) << "Jacobian requested for parameter block : " << i
                    << ". But the parameter block is marked constant.";
         return false;
       }

--- a/internal/ceres/program_evaluator.h
+++ b/internal/ceres/program_evaluator.h
@@ -283,7 +283,7 @@ class ProgramEvaluator final : public Evaluator {
     // It is possible that after accumulation that the cost has become infinite
     // or a nan.
     if (!std::isfinite(*cost)) {
-      LOG(ERROR) << "Accumulated cost = " << *cost
+      LOG(GLOG_ERROR) << "Accumulated cost = " << *cost
                  << " is not a finite number. Evaluation failed.";
       return false;
     }

--- a/internal/ceres/solver.cc
+++ b/internal/ceres/solver.cc
@@ -722,7 +722,7 @@ void Solver::Solve(const Solver::Options& options,
   double start_time = WallTimeInSeconds();
   *summary = Summary();
   if (!options.IsValid(&summary->message)) {
-    LOG(ERROR) << "Terminating: " << summary->message;
+    LOG(GLOG_ERROR) << "Terminating: " << summary->message;
     return;
   }
 
@@ -733,7 +733,7 @@ void Solver::Solve(const Solver::Options& options,
 #ifndef CERES_NO_CUDA
   if (IsCudaRequired(options)) {
     if (!problem_impl->context()->InitCuda(&summary->message)) {
-      LOG(ERROR) << "Terminating: " << summary->message;
+      LOG(GLOG_ERROR) << "Terminating: " << summary->message;
       return;
     }
   }

--- a/internal/ceres/subset_preconditioner.cc
+++ b/internal/ceres/subset_preconditioner.cc
@@ -107,7 +107,7 @@ bool SubsetPreconditioner::UpdateImpl(const BlockSparseMatrix& A,
       sparse_cholesky_->Factorize(inner_product_computer_->mutable_result(),
                                   &message);
   if (termination_type != LinearSolverTerminationType::SUCCESS) {
-    LOG(ERROR) << "Preconditioner factorization failed: " << message;
+    LOG(GLOG_ERROR) << "Preconditioner factorization failed: " << message;
     return false;
   }
 

--- a/internal/ceres/thread_pool_test.cc
+++ b/internal/ceres/thread_pool_test.cc
@@ -124,7 +124,7 @@ TEST(ThreadPool, Destructor) {
   // pass.
   const int num_hardware_threads = std::thread::hardware_concurrency();
   if (num_hardware_threads <= 1) {
-    LOG(ERROR)
+    LOG(GLOG_ERROR)
         << "Test not supported, the hardware does not support threading.";
     return;
   }
@@ -171,7 +171,7 @@ TEST(ThreadPool, Resize) {
   // pass.
   const int num_hardware_threads = std::thread::hardware_concurrency();
   if (num_hardware_threads <= 1) {
-    LOG(ERROR)
+    LOG(GLOG_ERROR)
         << "Test not supported, the hardware does not support threading.";
     return;
   }

--- a/internal/ceres/trust_region_minimizer.cc
+++ b/internal/ceres/trust_region_minimizer.cc
@@ -56,7 +56,7 @@
 #define RETURN_IF_ERROR_AND_LOG(expr)                            \
   do {                                                           \
     if (!(expr)) {                                               \
-      LOG(ERROR) << "Terminating: " << solver_summary_->message; \
+      LOG(GLOG_ERROR) << "Terminating: " << solver_summary_->message; \
       return;                                                    \
     }                                                            \
   } while (0)

